<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Ccsecure.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<style type="text/css">
<!--
/* default style sheet generated by perltidy */
body {background: #FFFFFF; color: #000000}
pre { color: #000000; 
      background: #F0F0F0;
      font-family: courier;
    } 

.c  { color: #228B22;} /* comment */
.cm { color: #000000;} /* comma */
.co { color: #000000;} /* colon */
.h  { color: #CD5555; font-weight:bold;} /* here-doc-target */
.hh { color: #CD5555; font-style:italic;} /* here-doc-text */
.i  { color: #00688B;} /* identifier */
.j  { color: #CD5555; font-weight:bold;} /* label */
.k  { color: #8B008B; font-weight:bold;} /* keyword */
.m  { color: #FF0000; font-weight:bold;} /* subroutine */
.n  { color: #B452CD;} /* numeric */
.p  { color: #000000;} /* paren */
.pd { color: #228B22; font-style:italic;} /* pod-text */
.pu { color: #000000;} /* punctuation */
.q  { color: #CD5555;} /* quote */
.s  { color: #000000;} /* structure */
.sc { color: #000000;} /* semicolon */
.v  { color: #B452CD;} /* v-string */
.w  { color: #000000;} /* bareword */
-->
</style>
<body style="background-color: white">
<a name="-top-"></a>
<h1>Ccsecure.pm</h1>


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
	<ul>

		<ul>

			<li><a href="#_get_digest">_get_digest</a></li>
			<li><a href="#text_to_hash">text_to_hash</a></li>
			<li><a href="#compare_password">compare_password</a></li>
			<li><a href="#calculate_token">calculate_token</a></li>
			<li><a href="#valid_token">valid_token</a></li>
			<li><a href="#calculate_api_key">calculate_api_key</a></li>
			<li><a href="#compare_api_key">compare_api_key</a></li>
			<li><a href="#hash_password">hash_password</a></li>
			<li><a href="#get_server_details">get_server_details</a></li>
			<li><a href="#gatekeeper">gatekeeper</a></li>
			<li><a href="#log_violation">log_violation</a></li>
			<li><a href="#random_password">random_password</a></li>
			<li><a href="#grumble">grumble</a></li>
			<li><a href="#is_admin">is_admin</a></li>
			<li><a href="#do_oauth">do_oauth</a></li>
		</ul>

	</ul>

</ul>

<hr name="index" />
</div>
<!-- INDEX END -->
<h2>Code Index:</h2>
<!-- BEGIN CODE INDEX --><a name="code-index"></a>
<ul>
<li><a href="#package-Ccsecure-">package Ccsecure</a>
<ul>
<li><a href="#_get_digest-">_get_digest</a></li>
<li><a href="#text_to_hash-">text_to_hash</a></li>
<li><a href="#compare_password-">compare_password</a></li>
<li><a href="#calculate_token-">calculate_token</a></li>
<li><a href="#valid_token-">valid_token</a></li>
<li><a href="#calculate_api_hash-">calculate_api_hash</a></li>
<li><a href="#compare_api_key-">compare_api_key</a></li>
<li><a href="#hash_password-">hash_password</a></li>
<li><a href="#get_server_details-">get_server_details</a></li>
<li><a href="#gatekeeper-">gatekeeper</a></li>
<li><a href="#log_violation-">log_violation</a></li>
<li><a href="#random_password-">random_password</a></li>
<li><a href="#install_grumble-">install_grumble</a></li>
<li><a href="#is_admin-">is_admin</a></li>
<li><a href="#encode_base64-">encode_base64</a></li>
<li><a href="#decode_base64-">decode_base64</a></li>
</ul>
</li>
<li><a href="#EOF-">EOF</a></li>
</ul>
<!-- END CODE INDEX -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Ccsecure.pm</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>Security routines for Cclite</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This package deals with session and security management. Currently sessions
are via tokens. Tokens are hashes of IP address and validated password.
They shouldn't work from a new address by being transported.</p>
<p>Action completes OK or it's a violation. If it's a violation, it's logged.</p>
<p>Note that nearly every other routine within Cclite can consume a token.
This is usually the last input parameter for any given subroutine.</p>
<p>This isn't used at present but the idea is many watertight doors rather
than a perimeter and a leaky interior.</p>
<p>I expect to put public key processing for GPG email
and similar here too.</p>
<p>This can now use the pure Perl SHA package.
The idea is to enable a full installation where a user may not be able
to use CPAN. However Digest::SHA2 will be much faster.</p>
<p>07/2011</p>
<p>Code is gradually being added for salted passwords and OAuth. This is turned
off at the moment, but will be 'on' within a couple of releases</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Hugh Barnard</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>(c) Hugh Barnard 2005 GPL Licenced</p>
<pre>
<span class="c">#</span>
<a name="package-Ccsecure-"></a><span class="k">package </span><span class="i">Ccsecure</span><span class="sc">;</span>

<span class="k">use</span> <span class="w">strict</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">vars</span> <span class="q">qw(@ISA @EXPORT)</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Exporter</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Ccu</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Cclitedb</span><span class="sc">;</span>
<span class="k">use</span> <span class="w">Cccookie</span><span class="sc">;</span>
<span class="c">#use MIME::Base64;</span>

<span class="c"># use Net::OAuth;       # for Oauth in a while...</span>
<span class="k">use</span> <span class="w">Ccconfiguration</span><span class="sc">;</span>    <span class="c"># new style configuration, read hash type...</span>
<span class="c">###use GnuPG qw( :algo );</span>

<span class="k">my</span> <span class="i">$VERSION</span> = <span class="n">1.00</span><span class="sc">;</span>
<span class="i">@ISA</span>    = <span class="q">qw(Exporter)</span><span class="sc">;</span>
<span class="i">@EXPORT</span> = <span class="q">qw(login</span>
  <span class="q">logout</span>
  <span class="q">hash_password</span>
  <span class="q">get_server_details</span>
  <span class="q">install_grumble</span>
  <span class="q">is_admin</span>
  <span class="q">compare_password</span>
  <span class="q">random_password</span>
  <span class="q">calculate_token</span>
  <span class="q">calculate_api_key</span>
  <span class="q">compare_api_key</span>
  <span class="q">do_oauth</span>
  <span class="q">gatekeeper</span>
  <span class="q">valid_token</span>
  <span class="q">parse_remote_user</span>
  <span class="q">log_violation</span>
  <span class="q">text_to_hash</span>
  <span class="q">encode_base64</span>
  <span class="q">decode_base64</span>
<span class="q">)</span><span class="sc">;</span>

<span class="c"># this will choose the hashing module type, hash processing</span>
<span class="c"># depends on this within _get_digest</span>

<span class="k">our</span> <span class="i">%messages</span>    = <span class="i">readmessages</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
<span class="k">our</span> <span class="i">$messagesref</span> = \<span class="i">%messages</span><span class="sc">;</span>

</pre><p></p>
<h3><a name="_get_digest">_get_digest</a></h3>
<p>Returns a SHA digest. Digest SHA1
is potentially collision prone but available on
many commodity hosting platforms, so it's default
if cclite can't find SHA2</p>
<p>FIXME: 7/2010 use Digest changed to require, so these are invoked at runtime,
performance hit but easier setup, also they are in a function, at present
=cut</p>
<pre>
<a name="_get_digest-"></a><span class="k">sub </span><span class="m">_get_digest</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">@hash_items</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$digest</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$sha2obj</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$type</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">%configuration</span> = <span class="i">readconfiguration</span><span class="s">(</span><span class="s">)</span> <span class="k">if</span> <span class="s">(</span> <span class="i">$0</span> !~ <span class="q">/ccinstall/</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$os</span><span class="cm">,</span> <span class="i">$distribution</span><span class="cm">,</span> <span class="i">$package_type</span> <span class="s">)</span> = <span class="i">get_os_and_distribution</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <span class="k">eval</span> <span class="s">{</span>
        <span class="k">if</span> <span class="s">(</span> <span class="i">$configuration</span>{<span class="w">hash_type</span>} <span class="k">eq</span> <span class="q">&#39;sha2&#39;</span> &amp;&amp; <span class="i">$os</span> <span class="k">ne</span> <span class="q">&#39;windows&#39;</span> <span class="s">)</span>
        <span class="s">{</span>
            <span class="k">require</span> <span class="w">Digest::SHA2</span><span class="sc">;</span>
            <span class="i">$type</span> = <span class="q">&quot;sha2&quot;</span><span class="sc">;</span>
        <span class="s">}</span> <span class="k">elsif</span> <span class="s">(</span> <span class="i">$configuration</span>{<span class="w">hash_type</span>} <span class="k">eq</span> <span class="q">&#39;sha1&#39;</span> <span class="s">)</span> <span class="s">{</span>
            <span class="k">require</span> <span class="w">Digest::SHA1</span><span class="sc">;</span>
            <span class="i">$type</span> = <span class="q">&quot;sha1&quot;</span><span class="sc">;</span>
        <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
            <span class="k">die</span>
<span class="q">&quot;bad hash type in configuration $configuration{hash_type}, must sha2 or sha1&quot;</span><span class="sc">;</span>
        <span class="s">}</span>
    <span class="s">}</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span><span class="i">$@</span><span class="s">)</span> <span class="s">{</span>
        <span class="k">die</span>
<span class="q">&quot;bad hash type in configuration $configuration{hash_type}, or digest sha1 or sha2 not present&quot;</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="k">if</span> <span class="s">(</span> <span class="i">$type</span> <span class="k">eq</span> <span class="q">&quot;sha2&quot;</span> <span class="s">)</span> <span class="s">{</span>
        <span class="i">$sha2obj</span> = <span class="w">new</span> <span class="w">Digest::SHA2</span> <span class="n">512</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">elsif</span> <span class="s">(</span> <span class="i">$type</span> <span class="k">eq</span> <span class="q">&quot;sha1&quot;</span> <span class="s">)</span> <span class="s">{</span>
        <span class="i">$sha2obj</span> = <span class="w">new</span> <span class="w">Digest::SHA1</span><span class="sc">;</span>
    <span class="s">}</span>
    <span class="i">$sha2obj</span><span class="i">-&gt;add</span><span class="s">(</span><span class="i">@hash_items</span><span class="s">)</span><span class="sc">;</span>
    <span class="i">$digest</span> = <span class="i">$sha2obj</span><span class="i">-&gt;b64digest</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>

    <span class="c"># make base64 digest URL safe without using encoder/decoder 12/2008</span>
    <span class="c"># only do this for strings to be put into urls...</span>
    <span class="c">###$digest =~ s/([^A-Za-z0-9])/sprintf(&quot;%%%02X&quot;, ord($1))/seg if ($url_type);</span>
    <span class="c">###$digest =~ tr!\+\|\=!\\-\_! if ($url_type);    # transform dificult escapes</span>
    <span class="i">$digest</span> =~ <span class="q">s/[\+\\\s\/\|\=]+//g</span> <span class="k">if</span> <span class="s">(</span><span class="i">$url_type</span><span class="s">)</span><span class="sc">;</span>   <span class="c"># remove difficult escapes</span>
       <span class="c">#$digest = encode_base64($digest) if ($url_type);   # remove spaces newlines, experimental</span>
    <span class="k">return</span> <span class="i">$digest</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="text_to_hash">text_to_hash</a></h3>
<p>This is a tramp function that exposes _get_digest</p>
<pre>
<a name="text_to_hash-"></a><span class="k">sub </span><span class="m">text_to_hash</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span><span class="i">$text</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$url_type</span> = <span class="n">0</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$hash</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="s">(</span><span class="i">$text</span><span class="s">)</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$hash</span><span class="sc">;</span>

<span class="s">}</span>

</pre><p></p>
<h3><a name="compare_password">compare_password</a></h3>
<p>Compares the input hashed password with the stored one.
Normally this would take place over an https connection too.</p>
<pre>
<a name="compare_password-"></a><span class="k">sub </span><span class="m">compare_password</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$password_in</span><span class="cm">,</span> <span class="i">$cleartext</span><span class="cm">,</span> <span class="i">$password_stored</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="i">$password_in</span> <span class="k">ne</span> <span class="i">$password_stored</span> <span class="s">)</span> <span class="s">{</span>    <span class="c"># already hashed</span>
        <span class="k">return</span> <span class="n">0</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
        <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="calculate_token">calculate_token</a></h3>
<p>The token is a hash of the user, their current address (avoids some man
in the middle and some replay and the private value which is never exposed
to the network and changed frequently (we hope).</p>
<p>The hashref is either the fields reference or the cookie reference</p>
<pre>
<a name="calculate_token-"></a><span class="k">sub </span><span class="m">calculate_token</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$registry_private_value</span><span class="cm">,</span> <span class="i">$fieldsref</span><span class="cm">,</span> <span class="i">$cookieref</span><span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span> =
      <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$package</span><span class="cm">,</span> <span class="i">$filename</span><span class="cm">,</span> <span class="i">$line</span> <span class="s">)</span> = <span class="k">caller</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$token</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$url_type</span> = <span class="n">1</span><span class="sc">;</span>    <span class="c"># these are url type hashes</span>
    <span class="k">if</span> <span class="s">(</span> !<span class="k">length</span><span class="s">(</span><span class="i">$cookieref</span><span class="s">)</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">my</span> <span class="s">(</span> <span class="i">$sec</span><span class="cm">,</span> <span class="i">$min</span><span class="cm">,</span> <span class="i">$hour</span><span class="cm">,</span> <span class="i">$mday</span><span class="cm">,</span> <span class="i">$mon</span><span class="cm">,</span> <span class="i">$year</span><span class="cm">,</span> <span class="i">$wday</span><span class="cm">,</span> <span class="i">$yday</span><span class="cm">,</span> <span class="i">$isdst</span> <span class="s">)</span> =
          <span class="k">localtime</span><span class="s">(</span><span class="k">time</span><span class="s">)</span><span class="sc">;</span>

        <span class="c">#FIXME: time gives a little volatility but improve EGD perhaps?</span>
        <span class="k">my</span> <span class="i">$nonce</span> = <span class="k">join</span><span class="s">(</span> <span class="q">&#39;&#39;</span><span class="cm">,</span> <span class="i">$sec</span><span class="cm">,</span> <span class="i">$min</span><span class="cm">,</span> <span class="i">$hour</span> <span class="s">)</span><span class="sc">;</span>
        <span class="i">$nonce</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$nonce</span> <span class="s">)</span><span class="sc">;</span>
        <span class="i">$token</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$fieldsref</span>-&gt;{<span class="q">&#39;userLogin&#39;</span>}<span class="cm">,</span>
            <span class="i">$nonce</span><span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span><span class="sc">;</span>
        <span class="k">return</span> <span class="s">(</span> <span class="i">$token</span><span class="cm">,</span> <span class="i">$nonce</span> <span class="s">)</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
        <span class="i">$token</span> = <span class="i">_get_digest</span><span class="s">(</span>
            <span class="i">$url_type</span><span class="cm">,</span>
            <span class="i">$cookieref</span>-&gt;{<span class="q">&#39;userLogin&#39;</span>}<span class="cm">,</span>
            <span class="i">$cookieref</span>-&gt;{<span class="q">&#39;token1&#39;</span>}<span class="cm">,</span>
            <span class="i">$remote_address</span>
        <span class="s">)</span><span class="sc">;</span>

        <span class="k">return</span> <span class="s">(</span> <span class="i">$token</span><span class="cm">,</span> <span class="k">undef</span> <span class="s">)</span><span class="sc">;</span>
    <span class="s">}</span>

<span class="s">}</span>

</pre><p></p>
<h3><a name="valid_token">valid_token</a></h3>
<p>recalculate the token for existing input, return true, if it still works
and compare it. Return 1 if the recalculated token is valid.</p>
<p>This is switched off at present and maybe should become dead code...</p>
<pre>
<a name="valid_token-"></a><span class="k">sub </span><span class="m">valid_token</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$registry_private_value</span><span class="cm">,</span> <span class="i">$user</span><span class="cm">,</span> <span class="i">$remote_address</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$url_type</span> = <span class="n">0</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$compare</span> =
      <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$registry_private_value</span><span class="cm">,</span> <span class="i">$user</span><span class="cm">,</span> <span class="i">$remote_address</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="i">$compare</span> == <span class="i">$token</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span> <span class="k">else</span> <span class="s">{</span>
        <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="calculate_api_key">calculate_api_key</a></h3>
<p>The hashed api key is the api key + the remote address</p>
<p>FIXME:This version loops through a list of comma separated allowed ip addresses. This is not very scalable and possibly error-prone
however, it does permit one cclite installation to serve several passthroughs</p>
<pre>
<a name="calculate_api_hash-"></a><span class="k">sub </span><span class="m">calculate_api_hash</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$db</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">@calculated_hashes</span><span class="sc">;</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$registry_error</span><span class="cm">,</span> <span class="i">$hash_ref</span> <span class="s">)</span> =
      <span class="i">Cclitedb::get_where</span><span class="s">(</span> <span class="q">&#39;local&#39;</span><span class="cm">,</span> <span class="i">$db</span><span class="cm">,</span> <span class="q">&#39;om_registry&#39;</span><span class="cm">,</span> <span class="q">&#39;*&#39;</span><span class="cm">,</span> <span class="q">&#39;id&#39;</span><span class="cm">,</span> <span class="n">1</span><span class="cm">,</span> <span class="q">&#39;&#39;</span><span class="cm">,</span> <span class="q">&#39;&#39;</span><span class="cm">,</span>
        <span class="q">&#39;&#39;</span> <span class="s">)</span><span class="sc">;</span>

 <span class="c"># space separated list of IP addresses, relaxed in 5/2010 to multiple spaces...</span>
    <span class="k">my</span> <span class="i">@allowed_ip_addresses</span> = <span class="k">split</span><span class="s">(</span> <span class="q">/\s+/</span><span class="cm">,</span> <span class="i">$hash_ref</span>-&gt;{<span class="q">&#39;allow_ip_list&#39;</span>} <span class="s">)</span><span class="sc">;</span>

    <span class="k">foreach</span> <span class="k">my</span> <span class="i">$ip_address</span> <span class="s">(</span><span class="i">@allowed_ip_addresses</span><span class="s">)</span> <span class="s">{</span>
        <span class="k">my</span> <span class="i">$merchant_key_hash</span> =
          <span class="i">_get_digest</span><span class="s">(</span> <span class="n">0</span><span class="cm">,</span> <span class="s">(</span> <span class="i">$hash_ref</span>-&gt;{<span class="q">&#39;merchant_key&#39;</span>} . <span class="i">$ip_address</span> <span class="s">)</span> <span class="s">)</span><span class="sc">;</span>
        <span class="k">push</span> <span class="i">@calculated_hashes</span><span class="cm">,</span> <span class="i">$merchant_key_hash</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="k">return</span> \<span class="i">@calculated_hashes</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="compare_api_key">compare_api_key</a></h3>
<p>FIXME: This is not in its final form, which should be OAuth based, this is proof of concept
If this fails, some logging should be included, possible break-in
The hashed api key is the api key (which should be a gpg key after a while) for the registry, the remote address</p>
<p>FIXME:This version loops through a list of comma separated addresses. This is not very scalable and possibly error-prone
however, it does permit a single cclite installation to serve several passthroughs</p>
<pre>
<a name="compare_api_key-"></a><span class="k">sub </span><span class="m">compare_api_key</span> <span class="s">{</span>

    <span class="k">my</span> <span class="s">(</span> <span class="i">$db</span><span class="cm">,</span> <span class="i">$merchant_key_hash</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$merchant_hash_array_ref</span> = <span class="i">calculate_api_hash</span><span class="s">(</span> <span class="i">$db</span><span class="cm">,</span> <span class="i">$token</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">@calculated_hashes</span> = <span class="i">@$merchant_hash_array_ref</span><span class="sc">;</span>

    <span class="c"># retranslate from url-safe translation in php module</span>
    <span class="i">$merchant_key_hash</span> =~ <span class="q">tr/-_/+\//</span><span class="sc">;</span>

<span class="c"># not pretty because if any of them match, it returns...bad scale and doesn&#39;t ensure that the &#39;right&#39; one...</span>
    <span class="k">foreach</span> <span class="k">my</span> <span class="i">$hash</span> <span class="s">(</span><span class="i">@calculated_hashes</span><span class="s">)</span> <span class="s">{</span>
        <span class="k">if</span> <span class="s">(</span> <span class="i">$hash</span> <span class="k">eq</span> <span class="i">$merchant_key_hash</span> <span class="s">)</span> <span class="s">{</span>
            <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
        <span class="s">}</span>
    <span class="s">}</span>
    <span class="k">return</span> <span class="n">0</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="hash_password">hash_password</a></h3>
<p>put the password into a hash
changed this to change the hashing method, currently sha2</p>
<p>url_type is 0 
=cut</p>
<pre>
<a name="hash_password-"></a><span class="k">sub </span><span class="m">hash_password</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$cleartext</span> <span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>

    <span class="c"># password is always passed around as hash</span>
    <span class="k">my</span> <span class="i">$hash_value</span> = <span class="i">_get_digest</span><span class="s">(</span> <span class="i">$url_type</span><span class="cm">,</span> <span class="i">$cleartext</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$l</span> = <span class="k">length</span><span class="s">(</span><span class="i">$cleartext</span><span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$hash_value</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="get_server_details">get_server_details</a></h3>
<p>find out where served using environment variables
 ---- check for phishing here?</p>
<p>Domain is now deduced as first bit of path, not server correctly
on desktop debian for example 11/2009, this affects cookie release
as Laura's note...</p>
<p>FIXME: Not rigorous since https and 443 aren't 'married'</p>
<pre>
<a name="get_server_details-"></a><span class="k">sub </span><span class="m">get_server_details</span> <span class="s">{</span>

    <span class="k">my</span> <span class="i">$portstring</span> = <span class="q">&quot;:$ENV{SERVER_PORT}&quot;</span>
      <span class="k">if</span> <span class="s">(</span> <span class="i">$ENV</span>{<span class="w">SERVER_PORT</span>} != <span class="n">80</span> &amp;&amp; <span class="i">$ENV</span>{<span class="w">SERVER_PORT</span>} != <span class="n">443</span> <span class="s">)</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$domain</span> = <span class="i">$ENV</span>{<span class="w">SERVER_NAME</span>}<span class="sc">;</span>

    <span class="k">my</span> <span class="i">$httpstring</span> = <span class="q">&quot;http://&quot;</span><span class="sc">;</span>
    <span class="i">$httpstring</span> = <span class="q">&quot;https://&quot;</span> <span class="k">if</span> <span class="s">(</span> <span class="i">$ENV</span>{<span class="w">SERVER_PORT</span>} == <span class="n">443</span> <span class="s">)</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$home</span> = <span class="q">&quot;$httpstring$domain$portstring$ENV{SCRIPT_NAME}&quot;</span><span class="sc">;</span>

    <span class="k">return</span> <span class="s">(</span> <span class="i">$home</span><span class="cm">,</span> <span class="i">$domain</span> <span class="s">)</span><span class="sc">;</span>

<span class="s">}</span>



</pre><p></p>
<h3><a name="gatekeeper">gatekeeper</a></h3>
<p>Routine to protect batch scripts by testing token cookies</p>
<pre>

<a name="gatekeeper-"></a><span class="k">sub </span><span class="m">gatekeeper</span> <span class="s">{</span>
	
	
	
	
<span class="s">}</span>	
	



</pre><p></p>
<h3><a name="log_violation">log_violation</a></h3>
<p>Log token failures etc. here..needs a new db table
creates a record in om_log, type, user, ipaddress</p>
<p>There also needs to be a fingerprint log for transactions too</p>
<p>This is probably taken care of using log4perl right now</p>
<pre>
<a name="log_violation-"></a><span class="k">sub </span><span class="m">log_violation</span> <span class="s">{</span>

    <span class="k">return</span> <span class="n">1</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="random_password">random_password</a></h3>
<p>Generate a fairly random password for one that's
been forgotten</p>
<pre>
<a name="random_password-"></a><span class="k">sub </span><span class="m">random_password</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$password</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$_rand</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$password_length</span> = <span class="i">$_</span>[<span class="n">0</span>]<span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> !<span class="i">$password_length</span> <span class="s">)</span> <span class="s">{</span>
        <span class="i">$password_length</span> = <span class="n">10</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="k">my</span> <span class="i">@chars</span> = <span class="k">split</span><span class="s">(</span>
        <span class="q">&quot; &quot;</span><span class="cm">,</span>
        <span class="q">&quot;a b c d e f g h i j k l m n o p q r s t u v w x y z </span>
  <span class="q">  - _ % # |</span>
  <span class="q">  0 1 2 3 4 5 6 7 8 9&quot;</span>
    <span class="s">)</span><span class="sc">;</span>

    <span class="k">srand</span><span class="sc">;</span>

    <span class="k">for</span> <span class="s">(</span> <span class="k">my</span> <span class="i">$i</span> = <span class="n">0</span> <span class="sc">;</span> <span class="i">$i</span> &lt;= <span class="i">$password_length</span> <span class="sc">;</span> <span class="i">$i</span>++ <span class="s">)</span> <span class="s">{</span>
        <span class="i">$_rand</span> = <span class="k">int</span><span class="s">(</span> <span class="k">rand</span> <span class="n">41</span> <span class="s">)</span><span class="sc">;</span>
        <span class="i">$password</span> .= <span class="i">$chars</span>[<span class="i">$_rand</span>]<span class="sc">;</span>
    <span class="s">}</span>
    <span class="k">return</span> <span class="i">$password</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="grumble">grumble</a></h3>
<p>grumble about installer present and writable files etc.
mainly installer for the present</p>
<p>Added $installer_present to get menu link in ccadmin.cgi</p>
<pre>
<a name="install_grumble-"></a><span class="k">sub </span><span class="m">install_grumble</span> <span class="s">{</span>

    <span class="k">my</span> <span class="i">$base_path</span> = <span class="i">$0</span><span class="sc">;</span>
    <span class="i">$base_path</span> =~ <span class="q">s/^(.*?)\/cgi-bin.*$/$1/</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">$installer_present</span> = <span class="n">0</span><span class="sc">;</span>

    <span class="k">my</span> <span class="i">@grumbles</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$configfile</span> = <span class="q">&quot;$base_path/config/cclite.cf&quot;</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="k">-e</span> <span class="i">$configfile</span> &amp;&amp; <span class="k">-w</span> <span class="i">$configfile</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">push</span> <span class="i">@grumbles</span><span class="cm">,</span> <span class="i">$messages</span>{<span class="q">&#39;cclitecfinsecure&#39;</span>}<span class="sc">;</span>
    <span class="s">}</span>
    <span class="k">my</span> <span class="i">$cgiinstall</span> = <span class="q">&quot;$base_path/cgi-bin/protected/ccinstall.cgi&quot;</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="k">-e</span> <span class="i">$cgiinstall</span> &amp;&amp; <span class="k">-x</span> <span class="i">$cgiinstall</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">push</span> <span class="i">@grumbles</span><span class="cm">,</span> <span class="i">$messages</span>{<span class="q">&#39;ccinstallinsecure&#39;</span>}<span class="sc">;</span>
        <span class="i">$installer_present</span> = <span class="n">1</span><span class="sc">;</span>
    <span class="s">}</span>

    <span class="c"># grumble about soap server also insecure</span>
    <span class="k">my</span> <span class="i">$soapserver</span> = <span class="q">&quot;$base_path/cgi-bin/ccserver.cgi/&quot;</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span> <span class="k">-e</span> <span class="i">$soapserver</span> &amp;&amp; <span class="k">-x</span> <span class="i">$soapserver</span> <span class="s">)</span> <span class="s">{</span>
        <span class="k">push</span> <span class="i">@grumbles</span><span class="cm">,</span> <span class="i">$messages</span>{<span class="q">&#39;ccsoapserverinsecure&#39;</span>}<span class="sc">;</span>
    <span class="s">}</span>

    <span class="c"># turn off this grumble for the moment: people don&#39;t want it 10/2009</span>
    <span class="c"># and hard to fix...</span>
    <span class="c">###   if ( $ENV{SERVER_PORT} != 443 ) {</span>
    <span class="c">###       push @grumbles, &quot;please use https if possible!&quot;;</span>
    <span class="c">###  }</span>
    <span class="k">my</span> <span class="s">(</span> <span class="i">$os</span><span class="cm">,</span> <span class="i">$distribution</span><span class="cm">,</span> <span class="i">$package_type</span> <span class="s">)</span> = <span class="i">get_os_and_distribution</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$grumbling</span><span class="sc">;</span>
    <span class="i">$grumbling</span> = <span class="k">join</span><span class="s">(</span> <span class="q">&quot;&lt;br/&gt;&quot;</span><span class="cm">,</span> <span class="i">@grumbles</span> <span class="s">)</span> <span class="k">if</span> <span class="s">(</span> <span class="i">$os</span> <span class="k">ne</span> <span class="q">&#39;windows&#39;</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="s">(</span> <span class="i">$installer_present</span><span class="cm">,</span> <span class="i">$grumbling</span> <span class="s">)</span><span class="sc">;</span>
<span class="s">}</span>

</pre><p></p>
<h3><a name="is_admin">is_admin</a></h3>
<p>Very crude method of determining whether the administration script is being run.
Should be replaced by something more secure and subtle.</p>
<p>FIXME: Should also check token to provide some assurance that session is not hijacked</p>
<pre>
<a name="is_admin-"></a><span class="k">sub </span><span class="m">is_admin</span> <span class="s">{</span>
    <span class="k">my</span> <span class="i">$is_admin</span>  = <span class="n">0</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$cookieref</span> = <span class="i">get_cookie</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
    <span class="i">$is_admin</span> = <span class="n">1</span> <span class="k">if</span> <span class="s">(</span> <span class="i">$cookieref</span>-&gt;{<span class="w">userLevel</span>} <span class="k">eq</span> <span class="q">&quot;admin&quot;</span> <span class="s">)</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$is_admin</span><span class="sc">;</span>
<span class="s">}</span>

<a name="encode_base64-"></a><span class="k">sub </span><span class="m">encode_base64</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$data</span><span class="s">)</span> = <span class="i">@_</span> <span class="sc">;</span>
    <span class="i">$data</span> =~ <span class="q">tr|+/=|\-_|d</span><span class="sc">;</span>
    <span class="k">return</span> <span class="i">$data</span><span class="sc">;</span>
<span class="s">}</span>

<a name="decode_base64-"></a><span class="k">sub </span><span class="m">decode_base64</span> <span class="s">{</span>
    <span class="k">my</span> <span class="s">(</span><span class="i">$data</span><span class="s">)</span> = <span class="i">@_</span> <span class="sc">;</span>

    <span class="c"># +/ should not be handled, so convert them to invalid chars</span>
    <span class="c"># also, remove spaces (\t..\r and SP) so as to calc padding len</span>
    <span class="i">$data</span> =~ <span class="q">tr|\-_\t-\x0d |+/|d</span><span class="sc">;</span>
    <span class="k">my</span> <span class="i">$mod4</span> = <span class="k">length</span><span class="s">(</span><span class="i">$data</span><span class="s">)</span> % <span class="n">4</span><span class="sc">;</span>
    <span class="k">if</span> <span class="s">(</span><span class="i">$mod4</span><span class="s">)</span> <span class="s">{</span>
        <span class="i">$data</span> .= <span class="k">substr</span><span class="s">(</span> <span class="q">&#39;====&#39;</span><span class="cm">,</span> <span class="i">$mod4</span> <span class="s">)</span><span class="sc">;</span>
    <span class="s">}</span>
    <span class="k">return</span> <span class="i">$data</span><span class="sc">;</span>
<span class="s">}</span>


</pre><dl><dt><strong><a name="sha" class="item">cut
#
# Author:       David Shu
# Created:      5/26/2005
# Description:  This is a collection of functions that will assist in
#               working with salted SHA (SSHA) passwords.
#</a></strong></dt>

<dd>
<p>#
# Description:  Extracts the prefix portion of the hashed password
# Parameters:   hashed password =&gt; (required; the hashed password must contain
#               the appropriate prefix)
# Return: scheme (string)
#
sub getpassscheme {
    my $hashed_pass = shift;</p>
<pre>
    # extract prefix from hash
    $hashed_pass =~ m/{([^}]*)/;
    return $1;
}</pre>
<p>#
# Description : Extracts the hash portion of the hashed password
# Parameters : hashed password =&gt; (required; the hashed password must contain
#              the appropriate prefix)
# Return : hash (string)
#
sub getpasshash {
    my $hashed_pass = shift;</p>
<pre>
    # extract hash from passwordhash
    $hashed_pass =~ m/}([^s]*)/;
    return $1;
}</pre>
<p>#
# Description :    Generate a SHA or SSHA hash
# Parameters :     password =&gt; clear text (required)
#                  salted =&gt; boolean (optional; default = FALSE)
#                  salt =&gt; hexString (optional; default = &quot;&quot;; a random salt will be
# 			generated if none is provided
# Return : 	   Hash (string)
#
sub generatesha {
    my ( $password, $salted, $salt ) = @_;</p>
<pre>
    if ( $salted &amp;&amp; $salt eq &quot;&quot; ) {
        $salt = generatehexsalt();
    }</pre>
<pre>
    my $hashed_pass = &quot;&quot;;
    my $ctx         = Digest::SHA1-&gt;new;
    $ctx-&gt;add($password);
    print $password;
    if ($salted) {
        print $salt;
        $salt = pack( &quot;H*&quot;, $salt );
        $ctx-&gt;add($salt);
        $hashed_pass = encode_base64( $ctx-&gt;digest . $salt, '' );</pre>
<pre>
    } else {
        $hashed_pass = encode_base64( $ctx-&gt;digest, '' );
    }</pre>
<pre>
    return $hashed_pass;
}</pre>
<p>#
# Description : Generate a SHA or SSHA hashed password; same as generatesha
# 		but adds the appropriate prefix
# Parameters :  password =&gt; clear text (required)
# 		salted =&gt; boolean (optional; default = FALSE)
# 		salt =&gt; hexString (optional; default = &quot;&quot;; a random salt will be
# 			generated if none is provided
# Return : 	Hashed Password (string)
#
sub generateshawithprefix {
    my ( $password, $salted, $salt ) = @_;</p>
<pre>
    my $hashed_pass = &quot;&quot;;</pre>
<pre>
    if ( !$salted ) {
        $hashed_pass = &quot;{SHA}&quot; . generatesha( $password, $salted, $salt );
    } else {
        $hashed_pass = &quot;{SSHA}&quot; . generatesha( $password, $salted, $salt );
    }</pre>
<pre>
    return $hashed_pass;
}</pre>
<p>#
# Description : Randomly generate a 4 byte hex-based string
# Parameters : N/a
# Return : Hex based salt (string)
#
sub generatehexsalt {</p>
<pre>
    # RANDOM KEY PARAMETERS
    my @keychars = (
        &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;,
        &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;
    );
    my @keychars_initial = (
        &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;,
        &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;
    );
    my $length = 8;</pre>
<pre>
    # RANDOM KEY GENERATOR
    my $randkey = &quot;&quot;;
    for ( my $i = 0 ; $i &lt; $length ; $i++ ) {
        if ( $i == 0 ) {
            $randkey .= $keychars_initial[ int( rand(15) ) ];
        } else {
            $randkey .= $keychars[ int( rand(16) ) ];
        }
    }</pre>
<pre>
    return $randkey;
}</pre>
<p>#
# Description : Extracts the hex based salt that was used in the hashed password
# Parameters :  hashed password =&gt; (required; the hashed password must contain
# 		the appropriate prefix)
# Return : Hex based salt (string)
#
sub extractsalt {
    my ($hashed_pass) = @_;
    my $hash          = <code>getpasshash($hashed_pass)</code>;
    my $ohash         = decode_base64($hash);
    my $osalt = substr( $ohash, 20 );
    return join( &quot;&quot;, unpack( &quot;H*&quot;, $osalt ) );
}</p>
<p>#
# Description : Compare the hashed password with the clear text password;
# 		Currently this only supports 3 password schemes (all are
# 		base64 encoded):
# 			1) SSHA (sha1 algorithm)
# 			2) SHA (sha1 algorithm)
# 			3) MD5
# Parameters :  hashed password =&gt; (required; the hashed password must contain
# 		the appropriate prefix)
# 		cleartext password =&gt; (required)
# Return : 	1/0
#
sub validatepassword {
    my ( $hashed_pass, $clear_pass ) = @_;
    my $scheme = lc( <code>getpassscheme($hashed_pass)</code> );
    my $hash   = <code>getpasshash($hashed_pass)</code>;
    $clear_pass =~ s/^s+//g;
    $clear_pass =~ s/s+$//g;
    my $retval = 0;
    if ( $scheme eq &quot;ssha&quot; ) {
        my $salt = <code>extractsalt($hashed_pass)</code>;
        my $hpass = generatesha( $clear_pass, 1, $salt );</p>
<pre>
        if ( $hash eq $hpass ) {
            $retval = 1;
        }
    } elsif ( $scheme eq &quot;sha&quot; ) {
        my $hpass = generatesha( $clear_pass, 0, &quot;&quot; );
        if ( $hash eq $hpass ) {
            $retval = 1;
        }
    } else {
        my $hpass = encode_base64( pack( &quot;H*&quot;, md5($clear_pass) ) );
        if ( $hash eq $hpass ) {
            $retval = 1;
        }
    }</pre>
<pre>
    return $retval;
}</pre>
<p># Skeleton OAuth processing 07/2011</p>
</dd>
</dl>
<p>
</p>
<h3><a name="do_oauth">do_oauth</a></h3>
<p>Experimental oauth token supply and checking etc. This is to complete
the open transact work and also to replace the hand-rolled api access
method in previous releases....</p>
<p>These calls exit here after supplying the tokens</p>
<p>sub do_oauth {</p>
<pre>
    my ( $class, $db, $fields_ref, $token ) = @_;</pre>
<pre>
    print &quot;Content-type: text/html\n\n&quot;;
    print &quot;in do auth $fields_ref-&gt;{'registry'}&quot;;</pre>
<pre>
    ###require &quot;Net::OAuth&quot; ;</pre>
<pre>
    # temporary parameters...
    $fields_ref-&gt;{'consumer_key'} = '123123';</pre>
<pre>
    $Net::OAuth::PROTOCOL_VERSION = 'Net::OAuth::PROTOCOL_VERSION_1_0A';</pre>
<pre>
    my $request = Net::OAuth-&gt;request(&quot;request token&quot;)-&gt;from_hash(
        {$fields_ref},
        consumer_key     =&gt; $fields_ref-&gt;{'consumer_key'},
        request_url      =&gt; $fields_ref-&gt;{'request_url'},
        signature_method =&gt; 'HMAC-SHA1',
        request_method   =&gt; $ENV{'REQUEST_METHOD'},
        timestamp        =&gt; time(),
        nonce            =&gt; '123123',
        consumer_secret  =&gt; '123123',
    );</pre>
<pre>
    if ( !$request-&gt;verify ) {
        die &quot;Signature verification failed&quot;;
    } else {</pre>
<pre>
        # Service Provider sends Request Token Response</pre>
<pre>
        my $response = Net::OAuth-&gt;response(&quot;request token&quot;)-&gt;new(
            token              =&gt; 'abcdef',
            token_secret       =&gt; '0123456',
            callback_confirmed =&gt; 'true',
        );</pre>
<pre>
        print $response-&gt;to_post_body;</pre>
<pre>
    }
    exit 0;
}
=cut</pre>

<pre>

<span class="n">1</span><span class="sc">;</span>

<a name="EOF-"></a></pre></body>

</html>
